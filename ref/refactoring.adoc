Piotr Góra,
Wojciech Dunia,
Marcin Jaskowski

= Snake.php










=== Przykład 1

Przed refaktoryzacją metoda writeGameOver() była wywoływana bez argumentu. Wypisywała na konsoli informację o końcu gry. Metoda to była zamknięta na zmiany. Po refaktoryzacji metoda może zostać wykorzystana do wypisania dowolnego tekstu na ekranie. Bez paramerów low i column tekst będzie automatycznie wypisywany na środku. Jeśli argumenty zostaną podanę tekst wyświetli się w określonym miejscu. Pozwoli to na wielokrotne wykorzystanie tej metody.


===== Przed refaktoryzacją 

[source,php]
----
public function writeGameOver()
    {
        $text = 'GAME OVER';
        $length = strlen($text);
        $col = ($this->width / 2) - ($length / 2);
        $row = $this->height / 2;

        for ($i = 0; $i < $length; ++$i) {
            $this->map[$row][$col] = $text[$i];
            ++$col;
        }
    }
----

===== Po refaktoryzacji 

[source,php]
----
public function writeStringOnBoard($text, $row = NULL , $column = NULL )
    {
        $length = strlen($text);
        
        if($row == NULL)
            {
                $row = $this->height / 2;
            }
        if($column == NULL)
            {    
                $column = ($this->width / 2) - ($length / 2);
            }
            
        for ($i = 0; $i < $length; ++$i) 
            {
                $this->map[$row][$column] = $text[$i];
                ++$column;
            }
    }
----


=== Przykład 2

Dodanie menu. Przed refaktoryzacją aplikcja uwzględniała jeden tryb gry. Nie było możliwości dodawania nowych funkcjonalności. Za pomocą stworzonych klas takich jak: Menu.php, ComponentMenu.php. Umożliwiono Dodawanie dodatkowych komponentów za pomocą obieku Component menu.


===== Główna pętla programu przed refaktoryzacją

[source,php]
----
	
public function run()
     {
        try 
        {
             while (true) {
                 $input = $this->terminal->getChar();
                 $this->board->moveSnake($input);
                 $this->drawBoard();
                 usleep(60000);
             }
         }
         catch (GameException $exception)
         {
             $this->gameOver();
         }
     }
----


===== Główna pętla programu po refaktoryzacji


[source,php]
----
public function run()
    {
        try 
        {
              system('clear');
                    
              $menu = new Menu($this->board, $this->terminal);
              $menu ->addComponentMenu(new MenuComponent('Zadanie','startGame'));
              $menu ->addComponentMenu(new MenuComponent('Opcje','newTextSide'));
              $menu ->addComponentMenu(new MenuComponent('Zapisz gre','newTextSide'));
              $menu ->addComponentMenu(new MenuComponent('Wyjscie','endGame'));
                    
              $menu ->drawMenu();
              
              $this->drawBoard();
                    
                while(true)
                    {
                        $input = $this->terminal->getChar();
                    
                        if($input != NULL)
                        {
                            $menu->interactWithMenu($input);
                        }    
                    }
            }
         catch (GameException $exception)
         {
            $this->gameOver();
            $this->board->removeBoard();
        }
    }
----


===== Klasa MenuComponent.php(dziedziczy po interfejsie MenuComponentInterface.php)


[source,php]
----
class MenuComponent extends MenuComponentInterface
{
    
    ...
    
	public function __construct(string $name, string   $functionName)
    {
    	    $this->name = $name;
            $this->functionName = $functionName;
    }

    ...

}
----


===== Klasa Menu.php


[source,php]
----
class Menu
{

    ...    
        
    public function addComponentMenu(MenuComponentInterface $menuComponent)
    {
       $this->menuComponentsArray[]=['name'=> $menuComponent->getName(), 
                                     'key'=>$this->computeKeyComponentMenuValue(),
                                     'functionName' => $menuComponent->getfunctionName()];
        
    }
    
    ...
    
}
----

[source,php]
----
class Menu
{

    ...    
        
    public function drawMenu()
    {
       
        foreach ($this->menuComponentsArray as $oneComponent)
        {
            $this->positionMenu($oneComponent);
        }
        
    }
    
    ...
    
}
----

[source,php]
----
class Menu
{

    ...    
        
    public function interactWithMenu($char)
    {   
        
        foreach ($this->menuComponentsArray as $oneComponent) 
        {
             if($oneComponent['key'] == $char)
             {
                
                call_user_func(array($this, $oneComponent['functionName']), $oneComponent['name']);
             }
        }
    }
    
    ...
    
}
----

[source,php]
----

//Przykładowa instacja klasy MenuComponent korzystająca z funkcji "interactWithMenu()"
// Object = new MenuComponent('Zacznij gre','startGame');


class Menu
{

    ...    
        
    ///Rozpoczecie,gry
    public function startGame()
    {
        while (true)
            {
                $input = $this->terminal->getChar();
                
                $this->board->moveSnake($input);
                $this->drawer->draw($this->board);
                usleep(60000);
            }
    }
    
    ...
    
}
----

= Refaktoryzacja 2

Refaktoryzacja ma na celu rozszerzenie możliwości programu o dodawanie dowolnych nowych obiektów na ekranie, dziedziczących właściwości po klasie Point. Obecnie program zakłada na sztywno tworzenie jednego obiektu o nazwie Coin.

na bazie metody randomCoins, która tworzy na ekranie obiekt klasy Coin:

.Board::randomCoins()
[source,php]
----
    public function randomCoins(int $count)
    {
        for ($i = 0; $i < $count; ++$i) {
            $col = rand(1, $this->width - 2);
            $row = rand(1, $this->height - 2);

            $this->coins[] = new Coin($row, $col);
        }
    }
----
tworzymy dodatkową, nową metodę, która będzie fabryką pojedynczych obiektów na planszy, oraz dodajemy zmienną instancyjną, będącą tablicą obiektów (starej metody nie ruszamy):

.Board::randomObjectsOnBoard()
[source,php]
----
    /**
     * @var ObjectsOnBoard[]:array
     */
    private $ObjectsOnBoard; // <1>

    public function randomObjectsOnBoard(Point $Object, int $count) // <2>
    {
        for ($i = 0; $i < $count; ++$i) {
            $col = rand(1, $this->width - 2);
            $row = rand(1, $this->height - 2);

            $this->ObjectsOnBoard[] = $Object($row, $col); // <3>
        }
    }
----
<1> Nowa tablica obiektów zamiast dotychczasowej $coins
<2> Zamiast *randomCoins* tworzymy bardziej uniwersalną *randomObjectsOnBoard*
<3> Przypisanie obiektu do tablicy


[NOTE]
====
Przeprowadzone testy nie wykazały błędów, przechodzimy do kolejnego etapu
====

w klasie Point przygotowujemy funkcję ustawiającą wstępne parametry obiektu, dzięki zastosowaniu tablicy, będzie można przekazywać specyficzne parametry, dostępne tylko dla danego typu obiektu na ekranie

.Point::setParams()
[source,php]
----
    public function setParams(array $params)
    {
        if (isset($params['row'])) $this->row = $params['row'];
        if (isset($params['col'])) $this->col = $params['col'];
        if (isset($params['char'])) $this->char = $params['char'];
    }
----

podmieniamy w konstruktorze klasy dotychczasowy sposób ustawiania parametrów:

.Point::__construct()
[source,php]
----
    public function __construct(int $row, int $col, string $char)
    {
        # $this->row = $row;
        # $this->col = $col;
        # $this->char = $char;
        $this->setParams(['row'=>$row,'col'=>$col,'char'=>$char]); // <1>
    }
----
<1> Przypisujemy parametry przez tablice, jest to zabieg potrzebny do zmiany parametów obiektu już po utworzeniu jego instancji, wcześniej nie było to możliwe

[NOTE]
====
Przeprowadzamy testy i przechodzimy do kolejnego etapu
====

W metodzie generującej nowe obiekty zmieniamy sposób ustawiania losowego położenia obiektu przekazanego w parametrze

.Board::randomObjectsOnBoard()
[source,php]
----
    public function randomObjectsOnBoard(Point $Object, int $count)
    {
      for ($i = 0; $i < $count; ++$i) {
          $col = rand(1, $this->width - 2);
          $row = rand(1, $this->height - 2);
          // Losowa aktualizacja położenia obiektu na ekranie
          $Object->setParams(['col'=>$col,'row'=>$row]); //<1>
          $this->ObjectsOnBoard[] = $Object; //<2>
      }
    }
----
<1> Przypisujemy do obiektu losowe położenie
<2> Przekazany obiekt dodajemy do tablicy

W konstruktorze planszy wywołujemy nową funkcję generowania losowych obiektów na ekranie:

.Board::__construct()
[source,php]
----
    public function __construct(int $width, int $height)
    {
        $this->width = $width;
        $this->height = $height;

        $this->snake = new Snake($height, $width);

        // Stary sposób generowania obiektów
        $this->randomCoins(1);
        // Nowy sposób generowania obiektów na ekranie
        $this->randomObjectsOnBoard(new Coin(1, 2),1);

        $this->generateMap();
        $this->generateOutline();
        $this->sourceMap = $this->map;

        $this->applyElements();
    }
----

W metodzie checkCoins, również dodajemy nowy sposób generowania obiektów

.Board::checkCoins()
[source,php]
----
    private function checkCoins()
    {
        $head = $this->snake->getPoints()[0];

        if (!empty($this->Coins)) {
            foreach ($this->Coins as $index => $coin) {
                if ($head->overlaps($coin)) {
                    $this->snake->advance();
                    unset($this->Coins[$index]);
                    // Stary sposób generowania obiektów
                    $this->randomCoins(1); //<1>
                    // Nowy sposób generowania obiektów na ekranie
                    $this->randomObjectsOnBoard(new Coin(3, 4),1); //<2>
                }
            }
        }
    }
----
<1> starego sposobu na razie nie ruszamy
<2> Nowy sposób dodawania dowolnego obiektu na planszy

[NOTE]
====
Przeprowadzamy testy. Ponieważ nie ma błędów, możemy przystąpić do ostatecznego etapu.
====

Podmieniamy wszystkie wystąpienia dotychczasowej tablicy przechowującej obiekty na ekranie na nową

[source,php]
---- 
    // wszystkie
    $this->coins
    // zamieniamy na
    $this->ObjectsOnBoard
----

[NOTE]
====
Błędów brak, program działa prawidłowo. Od tego momentu działanie starych motod zostało zastąpione nowo utworzonymi.
====

Pozostało zakomentowanie a następnie usunięcie niepotrzebnych metod i ich wywołań.
Na poniższym listingu widać jeszcze, że należy zrefaktoryzować nazwy nieadekwatnych metod i zmiennych w postaci checkCoins na checkObjects oraz $coin na $object

.cała klasa Board
[source,php]
---- 
   <?php

declare (strict_types = 1);

namespace PhpSnake\Game;

use PhpSnake\Game\Board\Coin;
use PhpSnake\Game\Board\Point;
use PhpSnake\Terminal\Char;

class Board
{
    /**
     * @var int
     */
    private $width;

    /**
     * @var int
     */
    private $height;

    /**
     * @var array
     */
    private $map;

    /**
     * @var array
     */
    private $sourceMap;

    /**
     * @var Snake
     */
    private $snake;

    /**
     * @var Coin[]:array
     */
    # private $coins; //<1>

    /**
     * @var ObjectsOnBoard[]:array
     */
    private $ObjectsOnBoard;

    /**
     * @param int $width
     * @param int $height
     */
    public function __construct(int $width, int $height)
    {
        $this->width = $width;
        $this->height = $height;

        $this->snake = new Snake($height, $width);

        // Stary sposób generowania obiektów
        # $this->randomCoins(1); //<1>
        // Nowy sposób generowania obiektów na ekranie
        $this->randomObjectsOnBoard(new Coin(1, 1),1);

        $this->generateMap();
        $this->generateOutline();
        $this->sourceMap = $this->map;

        $this->applyElements();
    }

/*    public function randomCoins(int $count)
    {
        for ($i = 0; $i < $count; ++$i) {
            $col = rand(1, $this->width - 2);
            $row = rand(1, $this->height - 2);

            $this->coins[] = new Coin($row, $col);
        }
    }*/ //<1>

    public function randomObjectsOnBoard($Object, int $count)
    {
      for ($i = 0; $i < $count; ++$i) {
          $col = rand(1, $this->width - 2);
          $row = rand(1, $this->height - 2);
          // Losowa aktualizacja położenia obiektu na ekranie
          $Object->setParams(['col'=>$col,'row'=>$row]);
          $this->ObjectsOnBoard[] = $Object;
      }
    }

    public function moveSnake(string $input)
    {
        $this->snake->move($input);
        $this->checkCoins(); //<2>
        $this->applyElements();
    }

    private function checkCoins() //<2>
    {
        $head = $this->snake->getPoints()[0];

        if (!empty($this->ObjectsOnBoard)) {
            foreach ($this->ObjectsOnBoard as $index => $coin) //<2>  
            {
                if ($head->overlaps($coin)) //<2>
                {
                    $this->snake->advance();
                    unset($this->ObjectsOnBoard[$index]);
                    // Stary sposób generowania obiektów
                    # $this->randomCoins(1); // <1>
                    // Nowy sposób generowania obiektów na ekranie
                    $this->randomObjectsOnBoard(new Coin(1, 1),1);
                }
            }
        }
    }

    /**
     * @return int
     */
    public function getWidth()
    {
        return $this->width;
    }

    /**
     * @return int
     */
    public function getHeight()
    {
        return $this->height;
    }

    /**
     * @return array
     */
    public function getMap()
    {
        return $this->map;
    }


    /**Funcion writing a string on board
    *
    */
    public function writeStringOnBoard($text, $row = NULL , $column = NULL )
    {

        $length = strlen($text);

        if($row == NULL)
        {
            $row = $this->height / 2;
        }

        if($column == NULL)
        {
        $column = ($this->width / 2) - ($length / 2);
        }


        for ($i = 0; $i < $length; ++$i) {
            $this->map[$row][$column] = $text[$i];
            ++$column;
        }
    }

    /**Function clear console after 2 seconds
    *
    */
    public function removeBoard()
    {
        sleep(2);
        system('clear');
    }

    private function applyElements()
    {
        $this->map = $this->sourceMap;

        foreach ($this->snake->getPoints() as $point) {
            $this->applyPoint($point);
        }

        if (!empty($this->ObjectsOnBoard)) {
            foreach ($this->ObjectsOnBoard as $coin) //<2>
            {
                $this->applyPoint($coin); //<2>
            }
        }

    }

    /**
     * @param Point $point
     */
    private function applyPoint(point $point)
    {
        $this->map[$point->getRow()][$point->getCol()] = $point->getChar();
    }

    public function generateMap()
    {
        for ($i = 0; $i < $this->height; ++$i) {
            $this->map[$i] = array_fill(0, $this->width, ' ');
        }
    }

    public function generateOutline()
    {
        $this->map[0][0] = Char::boxTopLeft();
        $this->map[0][$this->width - 1] = Char::boxTopRight();

        $this->generateHLine(0, 1, $this->width - 2, Char::boxHorizontal());
        $this->generateHLine($this->height - 1, 1, $this->width - 2, Char::boxHorizontal());

        $this->generateVLine(0, 1, $this->height - 2, Char::boxVertical());
        $this->generateVLine($this->width - 1, 1, $this->height - 2, Char::boxVertical());

        $this->map[$this->height - 1][0] = Char::boxBottomLeft();
        $this->map[$this->height - 1][$this->width - 1] = Char::boxBottomRight();
    }

    /**
     * @param int    $row
     * @param int    $start
     * @param int    $cols
     * @param string $char
     */
    private function generateHLine(int $row, int $start, int $cols, string $char)
    {
        for ($i = 0;$i < $cols;++$i) {
            $this->map[$row][$start + $i] = $char;
        }
    }

    /**
     * @param int    $col
     * @param int    $start
     * @param int    $rows
     * @param string $char
     */
    private function generateVLine(int $col, int $start, int $rows, string $char)
    {
        for ($i = 0;$i < $rows;++$i) {
            $this->map[$start + $i][$col] = $char;
        }
    }
}

----
<1> Zastąpione i zakomentowane zmienne i metody
<2> $coin i checkCoins() - do zastąpienia nowymi nazwami

[IMPORTANT]
====
Błędów brak, program jest otwarty za dopisanie klasy zeprezentującej nowy obiekt na ekranie.
====

Tworzymy nową klasę Bomb

.klasa Bomb extends Point
[source,php]
----
<?php

declare (strict_types = 1);

namespace PhpSnake\Game\Board;

class Bomb extends Point
{


    //private $arrayCoin = array("\033[41m\033[37m$\033[0m",
                               //"\033[43m\033[30m+\033[0m",
                              //  "\033[44m\033[30m#\033[0m");



    /**
     * @var string
     */
    private $char = "*";
    //private $char =  "\033[?25h\033[?0c";

     /**
     * @param int $row
     * @param int $col
     */
    public function __construct(int $row, int $col)
    {
       //$test= rand(0,2);
        parent::__construct($row, $col, $this->char);
    }
}

----

Dopisujemy wywołanie obiektu Bomb na ekranie
[source,php]
----
    public function __construct(int $width, int $height)
    {
        $this->width = $width;
        $this->height = $height;

        $this->snake = new Snake($height, $width);

        // Stary sposób generowania obiektów
        # $this->randomCoins(1);
        // Nowy sposób generowania obiektów na ekranie
        $this->randomObjectsOnBoard(new Coin(1, 2),1);
        $this->randomObjectsOnBoard(new Bomb(2, 3),1); //<1>

        $this->generateMap();
        $this->generateOutline();
        $this->sourceMap = $this->map;

        $this->applyElements();
    }
----
<1> Nowy obiekt o nowych parametrach

.Board::checkCoins()
[source,php]
----
    private function checkCoins()
    {
        $head = $this->snake->getPoints()[0];

        if (!empty($this->Coins)) {
            foreach ($this->Coins as $index => $coin) {
                if ($head->overlaps($coin)) {
                    $this->snake->advance();
                    unset($this->Coins[$index]);
                    // Nowy sposób generowania obiektów na ekranie
                    rand(0,1)==0 ? $this->randomObjectsOnBoard(new Coin(3, 4),1):$this->randomObjectsOnBoard(new Bomb(3, 4),1); //<1>
                }
            }
        }
    }
----
<1> Po "zjedzeniu" obiektu przez węża, odnawiamy losowo obiekt

.Wnioski końcowe z Refaktoryzacji nr 2
[TIP]
====
Dzięki przeprowadzonej refaktoryzacji możemy dodać dowolny nowy obiekt na ekranie, posiadający inne właściwości. Rozbudowy możemy dokonać przez dopisanie kodu klasy dziedziczącej po Point, a nie przez zmianę istniejącego kodu. Przed refaktoryzacją program był zamknięty na tego typu zmianę.
====








